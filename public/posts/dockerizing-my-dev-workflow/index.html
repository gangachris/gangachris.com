<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Dockerizing My Dev Workflow | NIH isn&#39;t a 4 letter word</title>
<link rel="stylesheet" href="https://gangachris.com/css/style.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://gangachris.com"><h1 class="title is-4">NIH isn&#39;t a 4 letter word</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/gangachris">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/gangachris_">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://www.linkedin.com/in/gangachris/">
            <span class="icon">
              <i class="fa fa-linkedin"></i>
            </span>
          </a>
          
          <a class="level-item" href="mailto:ganga.chris@gmail.com">
            <span class="icon">
              <i class="fa fa-envelope"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h2 class="subtitle is-6">July 10, 2016</h2>
    <h1 class="title">Dockerizing My Dev Workflow</h1>
    <div class="content">
      

<p>I’ve always just read about docker, for almost a year now, and recently decided to move all my development workflow to docker. I’ll briefly write about how I did this for two of the recent projects I’ve been working on, a mean stack application, and a Laravel-Postgres application.</p>

<p>I’m set up on a mac, and since docker is not natively supported on mac and Windows unless you have Virtual Box installed, I joined the <a href="https://beta.docker.com/">docker beta program</a>.</p>

<h2 id="googling-around-about-docker">Googling around about docker</h2>

<p>I’m more of a hands on, learn on the job type of person, so I just went directly into using docker. I’d say though that after googling around, the most helpful resources I found were The <a href="https://docs.docker.com/get-started/">official docker documentation</a>, <a href="https://flipboard.com/@dwahlin/the-docker-%26-kubernetes-magazine-vp93fvnrz">Dan Wahlin’s Docker Magazine on Flipboard</a> and <a href="https://www.pluralsight.com/courses/docker-deep-dive">Nigel Pulton’s Docker Deep Dive course</a>.</p>

<h2 id="dockerizing-the-mean-app">Dockerizing the MEAN app.</h2>

<p>The app is built on Mongo Express Angular 1.x and Node. From what I had gathered, I’d only need two docker containers. One for the App, and one for the mongo database.</p>

<h4 id="dockerfile">Dockerfile</h4>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dockerfile" data-lang="dockerfile"><span style="color:#00f">FROM</span><span style="color:#a31515"> node:4.4.2</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#008000"># Working Directory</span><span style="">
</span><span style=""></span><span style="color:#00f">WORKDIR</span><span style="color:#a31515"> /opt/app</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#008000"># Add project files to WORKDIR</span><span style="">
</span><span style=""></span><span style="color:#00f">ADD</span><span style="color:#a31515"> . /opt/app</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#008000"># Install the dependencies</span><span style="">
</span><span style=""></span><span style="color:#00f">RUN</span> npm install -g gulp bower<span style="">
</span><span style=""></span><span style="color:#00f">RUN</span> rm -Rf /opt/node_modules<span style="">
</span><span style=""></span><span style="color:#00f">RUN</span> npm install<span style="">
</span><span style=""></span><span style="color:#00f">RUN</span> mv node_modules/ /opt/<span style="">
</span><span style=""></span><span style="color:#00f">RUN</span> gulp<span style="">
</span><span style="">
</span><span style=""></span><span style="color:#008000"># Expose the port</span><span style="">
</span><span style=""></span><span style="color:#00f">EXPOSE</span><span style="color:#a31515"> 5555</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#008000">## Run app</span><span style="">
</span><span style=""></span><span style="color:#00f">CMD</span><span style="color:#a31515"> npm start</span></code></pre></div>

<p><code>npm install</code> can be really slow, and the folder gets deleted when the volume is mounted, so a workaround is to install node dependencies globally. That’s what the <code>RUN mv node_modules/ /opt/</code> does.</p>

<p>The difference with RUN and CMD is that RUN occurs during the build process of the container, while CMD occurs after the container has been built. The distinction is particularly important because if a container depends on another, some resources are usually not available during the build phase of either container, for instance, the links’ host names.</p>

<h4 id="docker-compose-yml">docker-compose.yml</h4>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">version: <span style="color:#a31515">&#39;2&#39;</span>
services:

  app:
    build: .
    ports:
      - <span style="color:#a31515">&#34;5555:5555&#34;</span>
    volumes:
      - .:/opt/app
    links:
      - mongodb
    depends_on:
      - mongodb

  mongodb:
    image: mongo:3.2
    ports:
      - <span style="color:#a31515">&#34;27017:27017&#34;</span></code></pre></div>

<p>The docker-compose file is used to set up multiple containers and connect them together. You could also use it for just one container. This docker-compose defines two containers, one for the app, and the other for the MongoDB.</p>

<p>What to note here is that when we run <code>docker-compose up</code>, a network based on the name of my project is created. The <code>links</code> attribute of the app creates a host with that particular name (mongodb) within the network. So, if you want the MongoDB URL, you’d access it this way: <code>mongodb://mongodb:27017/your-db-name</code>.</p>

<p>That’s all the changes I needed to make and my Mean App was all dockerized. Running <code>docker-compose up</code>, set up everything, and my app was running on the expected port. There’s probably more I could do, but I’m just getting started.</p>

<h2 id="dockerizing-the-laravel-postgres-app">Dockerizing the Laravel-Postgres app</h2>

<p>After doing the mean app, I thought the Laravel App would be straight forward (Probably a copy pasting kind of thing), It wasn’t.</p>

<p>Laravel has some requirements that the default PHP installation does not come with, Like the PDO for the particular database you want to use. After fiddling around with trial and errors, this is what I came up with.</p>

<h4 id="dockerfile-1">Dockerfile</h4>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-dockerfile" data-lang="dockerfile"><span style="color:#00f">FROM</span><span style="color:#a31515"> php:7</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#008000"># Work Dir</span><span style="">
</span><span style=""></span><span style="color:#00f">WORKDIR</span><span style="color:#a31515"> /opt/app</span><span style="">
</span><span style=""></span><span style="color:#00f">ADD</span><span style="color:#a31515"> . /opt/app</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#008000"># Install Dependencies</span><span style="">
</span><span style=""></span><span style="color:#00f">RUN</span> apt-get update &amp;&amp; apt-get install -y <span style="color:#a31515">\
</span><span style="color:#a31515"></span>      libpq-dev <span style="color:#a31515">\
</span><span style="color:#a31515"></span>    &amp;&amp; docker-php-ext-install pdo_pgsql<span style="">
</span><span style="">
</span><span style=""></span><span style="color:#00f">RUN</span> curl -sS https://getcomposer.org/installer | php<span style="">
</span><span style=""></span><span style="color:#00f">RUN</span> mv composer.phar /usr/local/bin/composer<span style="">
</span><span style=""></span><span style="color:#00f">RUN</span> chmod +x /usr/local/bin/composer<span style="">
</span><span style="">
</span><span style=""></span><span style="color:#00f">CMD</span><span style="color:#a31515"> composer install</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#008000"># Expose the port</span><span style="">
</span><span style=""></span><span style="color:#00f">EXPOSE</span><span style="color:#a31515"> 8000</span><span style="">
</span><span style="">
</span><span style=""></span><span style="color:#008000"># Run the app</span><span style="">
</span><span style=""></span><span style="color:#00f">CMD</span><span style="color:#a31515"> php artisan serve --host=0.0.0.0 --port=8000</span></code></pre></div>

<p>Going through the <a href="https://hub.docker.com/_/php/">official docker container image for php</a>, it’s mention how to install and configure php extensions with <code>docker-php-ext-install</code> and <code>docker-php-ext-enable</code>.</p>

<p>The extensions are however compiled when downloaded, so we have to install their corresponding compile/helper libraries. In this case, since I’m installing the <code>pdo_pgsql</code> PHP extension, I have to also install <code>libpq-dev</code> that will assist in it’s compilation.</p>

<p>Notice that I use <code>CMD composer install</code> instead of <code>RUN composer install</code>. This is just to clarify that composer install is not part of the build task for the docker container. The reason for this is that I had a php artisan migrate as part of the scripts to run after composer install in my <code>composer.json</code> file.</p>

<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#a31515">&#34;scripts&#34;</span> <span style="">:</span> {
  &#34;post-install-cmd&#34;: [
      <span style="color:#a31515">&#34;php artisan clear-compiled&#34;</span>,
      <span style="color:#a31515">&#34;php artisan optimize&#34;</span>,
      <span style="color:#a31515">&#34;php artisan migrate --force&#34;</span>
    ]
}</code></pre></div>

<p>This task requires that we have a connection to the database. I mentioned this above, but just to iterate: During the build task, a docker container does not have access to the network created by docker-compose. As a result, during the build phase, the laravel app will not have access to the database host (postgres) host I have specified in the <code>docker-compose</code> file below.</p>

<h4 id="docker-compose-yaml">docker-compose.yaml</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">version: <span style="color:#a31515">&#39;2&#39;</span>
services:

  app:
    build: .
    ports:
      - <span style="color:#a31515">&#34;8000:8000&#34;</span>
    volumes:
      - .:/opt/app
    links:
      - database
    depends_on:
      - database

  database:
    image: postgres
    environment:
      POSTGRES_PASSWORD: secret
      POSTGRES_USER: homestead
      POSTGRES_DB: homestead
    ports:
      - 5432</code></pre></div>
<p>The other minor change I had to make was in my <code>.env</code> database host to</p>

<h3 id="env">.env</h3>

<pre><code>DB_HOST=database
DB_DATABASE=homestead
DB_USERNAME=homestead
DB_PASSWORD=secret
</code></pre>

<p>Notice the hostname <code>(DB_HOST)</code> is the same as that on my docker-compose postgres container name.</p>

<p>That’s all. Running my setup was as simple as <code>docker-compose up</code>.</p>

<p>I later found out though, that there’s a <a href="http://laradock.io/">Laravel Homestead Docker implementation</a>.</p>

<p>I’ll go back to digging deeper into docker now, there’s more to my few lines of configuration on the docker-compose file, and I just had a brief look at docker swarm, from the recently concluded dockercon.</p>

    </div>
  </div>
</section>

<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'gangac';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p>&copy; <a href="https://github.com/gangachris">gangachris</a> 2018</p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


